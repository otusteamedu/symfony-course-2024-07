# Doctrine Migrations

Запускаем контейнеры командой `docker-compose up -d`

## Удаляем ручную миграцию и создаём автоматическую

1. Заходим в контейнер `php` командой `docker exec -it php sh`. Дальнейшие команды выполняются из контейнера
2. Очищаем БД, удаляя все таблицы запросом
    ```sql
    DROP TABLE author_follower;
    DROP TABLE subscription;
    DROP TABLE tweet;
    DROP TABLE feed;
    DROP TABLE "user";
    DROP TABLE doctrine_migration_versions;
    ```
3. Удаляем файл `migrations/Version20230305155514.php`
4. Генерируем новый файл миграции командой `php bin/console doctrine:migrations:diff`
5. Открываем сгенерированный файл и видим в методе `down` команду `$this->addSql('CREATE SCHEMA public');`

## Добавляем EventListener и перегенерируем миграцию

1. Создаём класс `App\Application\Doctrine\PostGenerateSchemaEventListener`
    ```php
    <?php
    
    namespace App\Application\Doctrine;
    
    use Doctrine\Bundle\DoctrineBundle\Attribute\AsDoctrineListener;
    use Doctrine\DBAL\Schema\SchemaException;
    use Doctrine\ORM\Tools\Event\GenerateSchemaEventArgs;
    use Doctrine\ORM\Tools\ToolEvents;
    
    #[AsDoctrineListener(event: ToolEvents::postGenerateSchema, connection: 'default')]
    class PostGenerateSchemaEventListener
    {
        /**
         * @throws SchemaException
         */
        public function postGenerateSchema(GenerateSchemaEventArgs $args): void
        {
            $schema = $args->getSchema();
            if (!$schema->hasNamespace('public')) {
                $schema->createNamespace('public');
            }
        }
    }
     ```
2. Удаляем неправильно сгенерированный файл и перегенерируем его командой `php bin/console doctrine:migrations:diff`
3. Видим, что в сгенерированном файле ненужная команда не появилась

## Исправляем атрибуты, перегенерируем миграцию и правим вручную то, что нельзя получить автоматически

1. Обращаем внимание, что имена индексов в миграции сгенерированы автоматически
2. Добавляем к классу `App\Entity\Tweet` атрибут
    ```php
    #[ORM\Index(name: 'tweet__author_id__ind', columns: ['author_id'])]
    ```
3. Добавляем к классу `App\Entity\Subscription` атрибуты
    ```php
    #[ORM\Index(name: 'subscription__author_id__ind', columns: ['author_id'])]
    #[ORM\Index(name: 'subscription__follower_id__ind', columns: ['follower_id'])]
    ```
4. Удаляем неправильно сгенерированный файл и перегенерируем его командой
   `php bin/console doctrine:migrations:diff`
5. Исправляем в сгенерированной миграции вручную оставшиеся автоматически сгенерированными имена индексов и имена
   внешних ключей
    1. в функции `up`:
        ```php
        public function up(Schema $schema) : void
        {
           $this->addSql('CREATE TABLE subscription (id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, author_id BIGINT DEFAULT NULL, follower_id BIGINT DEFAULT NULL, PRIMARY KEY(id))');
           $this->addSql('CREATE INDEX subscription__author_id__ind ON subscription (author_id)');
           $this->addSql('CREATE INDEX subscription__follower_id__ind ON subscription (follower_id)');
           $this->addSql('CREATE TABLE tweet (id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL, text VARCHAR(140) NOT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, author_id BIGINT DEFAULT NULL, PRIMARY KEY(id))');
           $this->addSql('CREATE INDEX tweet__author_id__ind ON tweet (author_id)');
           $this->addSql('CREATE TABLE "user" (id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL, login VARCHAR(32) NOT NULL, created_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, updated_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, PRIMARY KEY(id))');
           $this->addSql('CREATE TABLE author_follower (author_id BIGINT NOT NULL, follower_id BIGINT NOT NULL, PRIMARY KEY(author_id, follower_id))');
           $this->addSql('CREATE INDEX author_follower__author_id__ind ON author_follower (author_id)');
           $this->addSql('CREATE INDEX author_follower__follower_id__ind ON author_follower (follower_id)');
           $this->addSql('ALTER TABLE subscription ADD CONSTRAINT subscription__author_id__fk FOREIGN KEY (author_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
           $this->addSql('ALTER TABLE subscription ADD CONSTRAINT subscription__follower_id__fk FOREIGN KEY (follower_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
           $this->addSql('ALTER TABLE tweet ADD CONSTRAINT tweet__author_id__fk FOREIGN KEY (author_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
           $this->addSql('ALTER TABLE author_follower ADD CONSTRAINT author_follower__author_id__fk FOREIGN KEY (author_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
           $this->addSql('ALTER TABLE author_follower ADD CONSTRAINT author_follower__follower_id__fk FOREIGN KEY (follower_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
        }
        ```
    2. в функции `down`:
        ```php
        public function down(Schema $schema) : void
        {
           $this->addSql('ALTER TABLE subscription DROP CONSTRAINT author_follower__follower_id__fk');
           $this->addSql('ALTER TABLE subscription DROP CONSTRAINT author_follower__author_id__fk');
           $this->addSql('ALTER TABLE tweet DROP CONSTRAINT tweet__author_id__fk');
           $this->addSql('ALTER TABLE author_follower DROP CONSTRAINT subscription__follower_id__fk');
           $this->addSql('ALTER TABLE author_follower DROP CONSTRAINT subscription__author_id__fk');
           $this->addSql('DROP TABLE subscription');
           $this->addSql('DROP TABLE tweet');
           $this->addSql('DROP TABLE "user"');
           $this->addSql('DROP TABLE author_follower');
        }
        ```

## Выполняем миграции и возвращаем соответствие схемы и БД

1. Выполняем миграцию командой `php bin/console doctrine:migrations:migrate`
2. Ещё раз генерируем миграцию, выравнивающую схему БД с описаниями Entity командой
   `php bin/console doctrine:migrations:diff`
3. Заходим в сгенерированный файл и видим, что имена индексов для отношения many-to-many переопределить не удаётся
4. Накатываем миграцию командой `php bin/console doctrine:migrations:migrate`
5. Проверяем в БД, что имена индексов изменились
6. Откатываем миграцию командой `php bin/console doctrine:migrations:migrate VERSION`, где VERSION - FQN класса с
   первой миграцией, создающей все таблицы (с экранированием обратного слэша)
7. Проверяем в БД, что имена индексов снова стали осмысленными
8. Снова накатываем последнюю миграцию командой `php bin/console doctrine:migrations:migrate`
9. Ещё раз генерируем выравнивающую миграцию командой `php bin/console doctrine:migrations:diff`, видим ошибку,
   говорящую о том, что расхождений больше нет

## Добавляем EventListener для заполнения мета-полей

1. Создаём интерфейс `App\Domain\Entity\HasMetaTimestampsInterface`
    ```php
    <?php
   
    namespace App\Domain\Entity;
   
    interface HasMetaTimestampsInterface
    {
        public function setCreatedAt(): void;
   
        public function setUpdatedAt(): void;
    }
    ```
2. Реализуем созданный интерфейс в классе `App\Domain\Entity\User` (нужные методы уже есть)
3. Создаём класс `App\Application\Doctrine\MetaTimestampsPrePersistEventListener`
    ```php
    <?php
    
    namespace App\Application\Doctrine;
    
    use App\Domain\Entity\HasMetaTimestampsInterface;
    use Doctrine\Bundle\DoctrineBundle\Attribute\AsDoctrineListener;
    use Doctrine\ORM\Events;
    use Doctrine\Persistence\Event\LifecycleEventArgs;
    
    #[AsDoctrineListener(event: Events::prePersist, connection: 'default')]
    class MetaTimestampsPrePersistEventListener
    {
        public function prePersist(LifecycleEventArgs $event): void
        {
            $entity = $event->getObject();
    
            if ($entity instanceof HasMetaTimestampsInterface) {
                $entity->setCreatedAt();
                $entity->setUpdatedAt();
            }
        }
    }
    ```
4. В классе `App\Domain\Service\UserService` исправляем метод `create`
    ```php
    public function create(string $login): User
    {
        $user = new User();
        $user->setLogin($login);
        $this->userRepository->create($user);
   
        return $user;
    }
    ```
5. В классе `App\Controller\WorldController` исправляем метод `hello`
    ```php
    public function hello(): Response
    {
        $user = $this->userService->create('J.R.R. Tolkien');

        return $this->json($user->toArray());
    }
    ```
6. Заходим по адресу `http://localhost:7777/world/hello`, видим данные нашего пользователя с проставленным временем
   создания и редактирования

## Добавляем атрибуты Entity Lifecycle для сущности User

1. Удаляем класс `App\Application\Doctrine\MetaTimestampsPrePersistEventListener`
2. В классе `App\Domain\Entity\User`
    1. Добавляем атрибут класса
        ```php
        #[ORM\HasLifecycleCallbacks]
        ```
    2. Исправляем методы `setCreatedAt` и `setUpdatedAt`, добавляя к каждому атрибут
        ```php
        #[ORM\PrePersist]
        ```
3. Заходим по адресу `http://localhost:7777/world/hello`, видим, что время в пользователе снова проставилось

## Добавляем редактирование для сущности User

1. В классе `App\Domain\Entity\User` добавляем для метода `setUpdatedAt` атрибут
    ```php
    #[ORM\PreUpdate]
    ```
2. В классе `App\Infrastructure\Repository\UserRepository` добавляем новые методы `find` и `updateLogin`
    ```php
    public function find(int $userId): ?User
    {
        $repository = $this->entityManager->getRepository(User::class);
        /** @var User|null $user */
        $user = $repository->find($userId);

        return $user;
    }
   
    public function updateLogin(User $user, string $login): void
    {
        $user->setLogin($login);
        $this->flush();
    }
    ```
3. В классе `App\Domain\Service\UserService` добавляем новый метод `updateUserLogin`
    ```php
    public function updateUserLogin(int $userId, string $login): ?User
    {
        $user = $this->userRepository->find($userId);
        if (!($user instanceof User)) {
            return null;
        }
        $this->userRepository->updateLogin($user, $login);

        return $user;
    }
    ```
4. В классе `App\Controller\WorldController` исправляем метод `hello` (в вызове `updateUserLogin` используем любой ID,
   который реально существует в БД)
    ```php
    public function hello(): Response
    {
        $user = $this->userService->updateUserLogin(1, 'My new user');
        [$data, $code] = $user === null ? [null, Response::HTTP_NOT_FOUND] : [$user->toArray(), Response::HTTP_OK];

        return $this->json($data, $code);
    }
    ```
5. Заходим по адресу `http://localhost:7777/world/hello`, видим, что поле `updatedAt` обновилось

## Добавляем использование QueryBuilder для select-запроса

1. В классе `App\Infrastructure\Repository\UserRepository` добавляем новый метод `findUsersByLoginWithQueryBuilder`
    ```php
    public function findUsersByLoginWithQueryBuilder(string $login): array
    {
        $queryBuilder = $this->entityManager->createQueryBuilder();
        $queryBuilder->select('u')
            ->from(User::class, 'u')
            ->andWhere($queryBuilder->expr()->like('u.login',':userLogin'))
            ->setParameter('userLogin', "%$login%");

        return $queryBuilder->getQuery()->getResult();
    }
    ```
2. В класс `App\Domain\Service\UserService` добавляем новый метод `findUsersByLoginWithQueryBuilder`
    ```php
    public function findUsersByLoginWithQueryBuilder(string $login): array
    {
        return $this->userRepository->findUsersByLoginWithQueryBuilder($login);
    }
    ```
3. В классе `App\Controller\WorldController` исправляем метод `hello`
    ```php
    public function hello(): Response
    {
        $users = $this->userService->findUsersByLoginWithQueryBuilder('Tolkien');
    
        return $this->json(array_map(static fn(User $user) => $user->toArray(), $users));
    }
    ```
4. Заходим по адресу `http://localhost:7777/world/hello`, видим найденные записи

## Добавляем использование QueryBuilder для update-запроса

1. В класс `App\Infrastructure\Repository\UserRepository` добавляем новый метод `updateUserLoginWithQueryBuilder`
    ```php
    public function updateUserLoginWithQueryBuilder(int $userId, string $login): void
    {
        $queryBuilder = $this->entityManager->createQueryBuilder();
        $queryBuilder->update(User::class,'u')
            ->set('u.login', ':userLogin')
            ->where($queryBuilder->expr()->eq('u.id', ':userId'))
            ->setParameter('userId', $userId)
            ->setParameter('userLogin', $login);

        $queryBuilder->getQuery()->execute();
    }
    ```
2. В класс `App\Domain\Service\UserService` добавляем новый метод `updateUserLoginWithQueryBuilder`
    ```php
    public function updateUserLoginWithQueryBuilder(int $userId, string $login): ?User
    {
        $user = $this->userRepository->find($userId);
        if (!($user instanceof User)) {
            return null;
        }
        $this->userRepository->updateUserLoginWithQueryBuilder($user->getId(), $login);
        
        return $user;
    }
    ```
3. В классе `App\Controller\WorldController` исправляем метод `hello` (используем любой ID, который реально существует
   в БД)
    ```php
    public function hello(): Response
    {
        /** @var User $user */
        $user = $this->userService->updateUserLoginWithQueryBuilder(1, 'User is updated');

        return $this->json($user->toArray());
    }
    ```
4. Заходим по адресу `http://localhost:7777/world/hello`, видим запись со старым логином и старым временем обновления
5. Проверяем, что в БД запись обновилась

## Исправляем QueryBuilder для update-запроса

1. В классе `App\Domain\Service\UserService` исправляем метод `updateUserLoginWithQueryBuilder`
    ```php

    public function updateUserLoginWithQueryBuilder(int $userId, string $login): ?User
    {
        $user = $this->userRepository->find($userId);
        if (!($user instanceof User)) {
            return null;
        }
        $this->userRepository->updateUserLoginWithQueryBuilder($user->getId(), $login);
        $this->userRepository->refresh($user);

        return $user;
    }
    ```
2. В классе `App\Controller\WorldController` исправляем метод `hello` (используем любой ID, который реально существует
   в БД)
    ```php
    public function hello(): Response
    {
        /** @var User $user */
        $user = $this->userService->updateUserLoginWithQueryBuilder(1, 'User is updated again');

        return $this->json($user->toArray());
    }
    ```
3. Заходим по адресу `http://localhost:7777/world/hello`, видим запись с новым логином, но старым временем обновления

## Добавляем DBAL QueryBuilder для update-запроса

1. В класс `App\Infrastructure\Repository\UserRepository` добавляем новый метод `updateUserLoginWithDBALQueryBuilder`
    ```php
    /**
     * @throws \Doctrine\DBAL\Exception
     */
    public function updateUserLoginWithDBALQueryBuilder(int $userId, string $login): void
    {
        $queryBuilder = $this->entityManager->getConnection()->createQueryBuilder();
        $queryBuilder->update('"user"')
            ->set('login', ':userLogin')
            ->where($queryBuilder->expr()->eq('id', ':userId'))
            ->setParameter('userId', $userId)
            ->setParameter('userLogin', $login);

        $queryBuilder->executeStatement();
    }
    ```
2. В класс `App\Domain\Service\UserService` добавляем новый метод `updateUserLoginWithDBALQueryBuilder`
    ```php
    public function updateUserLoginWithDBALQueryBuilder(int $userId, string $login): ?User
    {
        $user = $this->userRepository->find($userId);
        if (!($user instanceof User)) {
            return null;
        }
        $this->userRepository->updateUserLoginWithDBALQueryBuilder($user->getId(), $login);
        $this->userRepository->refresh($user);

        return $user;
    }
    ```
3. В классе `App\Controller\WorldController` исправляем метод `hello`
    ```php
    public function hello(): Response
    {
        /** @var User $user */
        $user = $this->userService->updateUserLoginWithDBALQueryBuilder(1, 'User is updated by DBAL');

        return $this->json($user->toArray());
    }
    ```
4. Заходим по адресу `http://localhost:7777/world/hello`, видим запись с новым логином

## Загружаем связанные таблицы через QueryBuilder

1. В класс `App\Infrastructure\Repository\UserRepository` добавляем новый метод `findUserWithTweetsWithQueryBuilder`
    ```php
    /**
     * @throws NonUniqueResultException
     */
    public function findUserWithTweetsWithQueryBuilder(int $userId): array
    {
        $queryBuilder = $this->entityManager->createQueryBuilder();
        $queryBuilder->select('u')
            ->from(User::class, 'u')
            ->where($queryBuilder->expr()->eq('u.id', ':userId'))
            ->setParameter('userId', $userId);
    
        return $queryBuilder->getQuery()->getOneOrNullResult(AbstractQuery::HYDRATE_ARRAY);
    }
    ```
2. В класс `App\Domain\Service\UserService` добавляем новый метод `findUserWithTweetsWithQueryBuilder`
    ```php
    public function findUserWithTweetsWithQueryBuilder(int $userId): array
    {
        return $this->userRepository->findUserWithTweetsWithQueryBuilder($userId);
    }
    ```
3. Исправляем класс `App\Controller\WorldController`
    ```php
    <?php
    
    namespace App\Controller;
    
    use App\Domain\Service\UserService;
    use App\Domain\Service\UserBuilderService;
    use Doctrine\ORM\NonUniqueResultException;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\Response;
    
    class WorldController extends AbstractController
    {
        public function __construct(
            private readonly UserService $userService,
            private readonly UserBuilderService $userBuilderService,
        ) {
        }
    
        /**
         * @throws NonUniqueResultException
         */
        public function hello(): Response
        {
            $user = $this->userBuilderService->createUserWithTweets(
                'Charles Dickens',
                ['Oliver Twist', 'The Christmas Carol']
            );
            $userData = $this->userService->findUserWithTweetsWithQueryBuilder($user->getId());
    
            return $this->json($userData);
        }
    }
    ```
4. Заходим по адресу `http://localhost:7777/world/hello`, видим, что твиты не подгружаются

## Исправляем запрос для получения связанных таблиц

1. В классе `App\Infrastructure\Repository\UserRepository` исправляем метод `findUserWithTweetsWithQueryBuilder`
    ```php
    /**
     * @throws NonUniqueResultException
     */
    public function findUserWithTweetsWithQueryBuilder(int $userId): array
    {
        $queryBuilder = $this->entityManager->createQueryBuilder();
        $queryBuilder->select('u', 't')
            ->from(User::class, 'u')
            ->leftJoin('u.tweets', 't')
            ->where($queryBuilder->expr()->eq('u.id', ':userId'))
            ->setParameter('userId', $userId);
    
        return $queryBuilder->getQuery()->getOneOrNullResult(AbstractQuery::HYDRATE_ARRAY);
    }
    ```
2. Заходим по адресу `http://localhost:7777/world/hello`, видим, что твиты подгружаются

## Добавляем использование DBAL QueryBuilder для связанных таблиц

1. В класс `App\Infrastructure\Repository\UserRepository` добавляем новый метод `findUserWithTweetsWithDBALQueryBuilder`
    ```php
    /**
     * @throws \Doctrine\DBAL\Exception
     */
    public function findUserWithTweetsWithDBALQueryBuilder(int $userId): array
    {
        $queryBuilder = $this->entityManager->getConnection()->createQueryBuilder();
        $queryBuilder->select('u', 't')
            ->from('"user"', 'u')
            ->leftJoin('u', 'tweet', 't', 'u.id = t.author_id')
            ->where($queryBuilder->expr()->eq('u.id', ':userId'))
            ->setParameter('userId', $userId);
    
        return $queryBuilder->executeQuery()->fetchAllNumeric();
    }
    ```
2. В класс `App\Domain\Service\UserService` добавляем новый метод `findUserWithTweetsWithDBALQueryBuilder`
    ```php
    public function findUserWithTweetsWithDBALQueryBuilder(int $userId): array
    {
        return $this->userRepository->findUserWithTweetsWithDBALQueryBuilder($userId);
    }
    ```
3. В классе `App\Controller\WorldController` исправляем метод `hello`
    ```php
    /**
     * @throws \Doctrine\DBAL\Exception
     */
    public function hello(): Response
    {
        $user = $this->userBuilderService->createUserWithTweets(
            'Charles Dickens',
            ['Oliver Twist', 'The Christmas Carol']
        );
        $userData = $this->userService->findUserWithTweetsWithDBALQueryBuilder($user->getId());

        return $this->json($userData);
    }
    ```
4. Заходим по адресу `http://localhost:7777/world/hello`, видим результат в виде JSON-строк
